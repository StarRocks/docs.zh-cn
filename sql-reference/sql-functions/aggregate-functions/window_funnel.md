# window_funnel

## 功能

根据滑动窗口中的事件链，计算得到其中存在的最大事件数。
该函数遵守如下规则：

* 在事件链中搜索第一个条件，并将事件计数器设置为1，这是滑动窗口启动的时刻。
* 如果事件链中，在窗口中的事件顺序发生，将计数器递增；如果超出了窗口，则计数器不再增加。
* 如果在不同的时间段，筛选出不同的事件链，则仅输出具有最长链的长度。

## 语法

```Haskell
output window_funnel(window, time, mode, array)
```

## 参数说明

* window：滑动窗户的大小，筛选出的事件链中第一个事件和最后一个事件的最大间隔，类型为BIGINT。单位取决于time。
* time：时间戳。类型目前支持date和datetime。
* mode：默认为0，表示执行最一般的漏斗计算。类型为INT。该参数通过设置不同的bit来添加限制，目前提供如下两种mode：DEDUPLICATION/FIXED。其中DEDUPLICATION表示被筛选出的事件链，不能在原事件链中有重复的事件，假设array参数为[event_type='A', event_type='B', event_type='C', event_type='D']，原事件链为A-B-C-B-D，由于事件B重复，那么筛选出的事件链只能是A-B-C。FIXED表示被筛选出的事件链，不能在原本的事件链中有跳跃的事件，假设array参数如上不变，原事件链为A-B-D-C，由于事件D跳跃，那么筛选出的事件链只能是A-B。
* array：有序的事件列表，类型为Array\<BOOLEAN\>。

## 返回值说明

类型为BIGINT，值为滑动时间窗口内连续触发事件的最大数量。

## 示例

示例一:
假设现在有表action:

```plain text
mysql> select * from action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 1    | 点击       | 2020-01-02 11:10:00 |
| 1    | 下单       | 2020-01-02 11:20:00 |
| 1    | 支付       | 2020-01-02 11:30:00 |
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 2    | 下单       | 2020-01-02 11:00:00 |
| 2    | 支付       | 2020-01-02 11:10:00 |
| 3    | 浏览       | 2020-01-02 11:20:00 |
| 3    | 点击       | 2020-01-02 12:00:00 |
| 4    | 浏览       | 2020-01-02 11:50:00 |
| 4    | 点击       | 2020-01-02 12:00:00 |
| 5    | 浏览       | 2020-01-02 11:50:00 |
| 5    | 点击       | 2020-01-02 12:00:00 |
| 5    | 下单       | 2020-01-02 11:10:00 |
| 6    | 浏览       | 2020-01-02 11:50:00 |
| 6    | 点击       | 2020-01-02 12:00:00 |
| 6    | 下单       | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

执行如下sql

```plain text
mysql> select uid, window_funnel(1800,time,0,[event_type='浏览', event_type='点击', 
        event_type='下单', event_type='支付']) AS level from action group by uid order by uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

示例二:

假设现在有表action1：

```plain text
mysql> select * from action1 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 2    | 浏览       | 2020-01-02 11:00:01 |
| 1    | 点击       | 2020-01-02 11:10:00 |
| 1    | 下单       | 2020-01-02 11:29:00 |
| 1    | 点击       | 2020-01-02 11:29:50 |
| 1    | 支付       | 2020-01-02 11:30:00 |
| 1    | 点击       | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

执行sql

```plain text
mysql> select uid, window_funnel(1800,time,0,[event_type='浏览', 
        event_type='点击', event_type='下单', event_type='支付']) AS level from action1 group by uid order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

我们注意到，对于uid=1，即使点击事件(2020-01-02 11:29:50)已经重复出现，但是最终依然输出4，因为我们使用了mode(0)。
我们将mode改为1，再次执行sql

```plain text
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

可以看到输出为3，此时筛选出的最长事件链为浏览-点击-下单。

示例三：

假设现在有表action2：

```plain text
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 2    | 浏览       | 2020-01-02 11:00:01 |
| 1    | 点击       | 2020-01-02 11:10:00 |
| 1    | 支付       | 2020-01-02 11:30:00 |
| 1    | 下单       | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 rows in set (0.01 sec)
```

执行sql

```plain text
mysql> select uid, window_funnel(1900,time,0,[event_type='浏览', event_type='点击', 
        event_type='下单', event_type='支付']) AS level from action2 group by uid order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

可以看到对于uid=1，输出的level为3，支付(2020-01-02 11:30:00)这一跳跃的事件并没阻断筛选出的事件链。
我们将mode改为2，再次执行sql

```plain text
mysql> select uid, window_funnel(1900,time,2,[event_type='浏览', event_type='点击', 
        event_type='下单', event_type='支付']) AS level from action2 group by uid order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 rows in set (0.06 sec)
```

可以看到输出为2，此时筛选出的最大事件链是浏览-点击。

## 关键字

window_funnel
